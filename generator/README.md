Circuit board (and acrylic) generator code
==========================================

This hot mess is what generates everything from the various other components in
the repository. The rough structure is as follows:

 - *parts* define off-the-shelf stuff;
 - *models* define 3D models for them (some parts share the same model, hence
   the distinction);
 - *primitives* are things drawn in Blender that define what (parts of) the
   circuit board looks like, which components go where, and the net names for
   their pins; and
 - *subcircuits* connect multiple primitives together via the generated,
   visually-pleasing routing on the front of the mainboard.

Primitives and subcircuits both operate on a CircuitBoard class, which in turn
contains a bunch of layers, as well as tacked-on acrylic plate definitions and
other mechanical data. The local coordinate system of a subcircuit can be
"warped" to achieve the circular transformation you see on the mainboard,
without actually warping the primitives they're built from -- the logic for
this is certainly the most complex part of all this, and god help you if you
have to or want to touch it. Finally, there is some text rendering support. The
text rather arbitrarily uses the Montserrat font from Google, and is rendered
with matplotlib (stop judging me!)

Once the gerbers are generated, [gerbertools](https://github.com/jvanstraten/gerbertools)
is used to turn them into SVGs and Wavefront OBJs, and to run electrical DRC on
them. Depending on how lazy I've been, you may have to build that module
yourself (it should be easy though, since it has virtually no dependencies
outside of a sane compiler toolchain). In total, the rules checked are short
circuits, unrouted nets, clearance (only logic-level, the 230V stuff is checked
manually), annular ring, and hole-to-hole distance. There is also some basic
netlist DRC support that ensures that logic nets in the clock circuit have
exactly one driver and at least one user, and that non-logic nets have at least
two connection points.

The entry point for all this is `compose_*.py`, awkwardly duplicated for the
two PCBs. As if that wasn't ugly enough yet, `post.py` post-processes the SVGs
generated by this and gerbertools to make see-through SVGs of the PCB, along
with net names and a notes layer that shows the pinout and sizing of all
components, which is quite useful for manually checking the circuit. In
general, the circuits are also listed in ASCII art in the primitives
directory... but I didn't go so far as to read those and do circuit-to-PCB
matching automatically. The PCB *is* the circuit.
